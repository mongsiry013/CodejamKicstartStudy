# 문제 설명

문제 링크 : [2019_Round_H_3_Elevanagram](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edd/00000000001a286d)

- 문제에서 설명해주는 배경 지식

  - 어떤 정수가 11로 나눠 떨어지는지 확인하는 방법

    ex) 8174958 은 11로 나눠 떨어진다.

    각 digit를 이용하면 (8 - 1 + 7 - 4 + 9 - 5 + 8) % 11 == 0 이기 때문이다.

- Input 과 Output
  - Input : 9개의 정수가 주어진다. 각 정수가 의미하는 건 1 ~ 9 의 digit 개수.
  - Output : 주어진 digit 들을 이용하여 11로 나눠떨어지는 수를 만들 수 있는가? "YES" / "NO"
  - Limits
    - 1 <= T <= 100 (Test Case)
    - 1 <= A1 + A2 + A3 + ... + A9
    - Test set 1
    
      0 <= Ai <= 20
    - Test set 2
      
      0 <= Ai <= 10 ^ 9

# 풀이 설명

- Test set 1

  각 digit의 개수를 입력으로 받았지만 각 digit 를 입력 받았다고 가정하자.
  
  ex) 1 : 3개, 2 : 2개, 3 ~ 8 : 0개, 9 : 2개 면 이런 배열을 만든다.
  
      [1, 1, 1, 2, 2, 9, 9]
      
  Test set 1 은 이 배열의 크기가 최대 180이다.
  
  이 배열의 이름을 D 라고 하겠다.
  
  dynamic programming 를 이용한다.
 
  - dp[idx][r][diff] (type : True / False)
    - idx : 배열 D 에서 idx 인덱스부터 고려한 subproblem
    - r : 11로 나눈 나머지가 r 이 되도록 만들 수 있는가?
    - diff : +/- 기호를 선택하였을 때 (+ 의 개수) - (- 의 개수) 가 diff 가 되도록 만들 수 있는가?
    - dp[idx][r][diff] 가 True 인 경우는 다음 2가지 경우이다.
      - dp[idx+1][(r + D[idx]) % 11][diff+1] 가 True 일 때
      - dp[idx+1][(r - D[idx]) % 11][diff-1] 가 True 일 때
      - 이외에는 False
    - 최종 답 : dp[0][0][0]

- Test set 2
  - Input 을 다음 값들로 치환하여 Test set 1 문제로 만들어 버릴 수 있다.
    - A[i] 가 짝수 인 경우 : A[i] 를 20으로 치환
    - A[i] 가 홀수 인 경우 : A[i] 를 19로 치환
  - 11로 나눈 나머지 계산이므로 나머지 값이 최대 11을 주기로 반복 되기 때문이다.
    - ex) 3을 20개 입력 받았다고 해보자.
    - (+) 가 0개인 경우 : (-3 * 20) mod 11 = 6
    - (+) 가 1개인 경우 : (-3 * 18) mod 11 = 1
    - (+) 가 2개인 경우 : (-3 * 16) mod 11 = 7
    - (+) 가 3개인 경우 : (-3 * 14) mod 11 = 2
    - (+) 가 4개인 경우 : (-3 * 12) mod 11 = 8
    - (+) 가 5개인 경우 : (-3 * 10) mod 11 = 3
    - (+) 가 6개인 경우 : (-3 * 8) mod 11 = 9
    - (+) 가 7개인 경우 : (-3 * 6) mod 11 = 4
    - (+) 가 8개인 경우 : (-3 * 4) mod 11 = 10
    - (+) 가 9개인 경우 : (-3 * 2) mod 11 = 5
    - (+) 가 10개인 경우 : 0 mod 11 = 0
    - (+) 가 11개인 경우 : (3 * 2) mod 11 = 6
    - ... 반복
  - A[i] 가 짝수 인지 홀수인지는 정보를 보존해야 한다.
  
    전체 digit 의 개수(모든 A[i]의 합)가 짝수이면 전체 +의 개수와 -의 개수가 같아야 하지만
    
    전체 digit 의 개수가 홀수이면 전체 +의 개수가 -의 개수보다 1개 많아야 한다.
    


# 풀이 코드
[`코드 보기`](./solution.py)
